<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FPS Damage Numbers Mockup</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Fixed: Use official Framer Motion CDN bundle with correct UMD export name -->
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.umd.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      html, body { margin: 0; padding: 0; background: #111; height: 100%; overflow: hidden; }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/javascript">
      const { useEffect, useRef, useState } = React;
      // Fixed: Framer Motion global UMD exposes window.framerMotion, not 'framer-motion'
      const motionLib = window.framerMotion || window["framer-motion"] || {};
      const { motion = {}, AnimatePresence = (p) => React.createElement(React.Fragment, null, p.children) } = motionLib;

      if (!motion.div) {
        console.warn("Framer Motion did not load properly from CDN.");
      }

      const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
      const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
      const HUMANOID_ASPECT = 360 / 200;

      function FPSDamageNumbersMockup() {
        const wrapRef = useRef(null);
        const [floats, setFloats] = useState([]);
        const [isDown, setIsDown] = useState(false);
        const [overTarget, setOverTarget] = useState(false);
        const [frameSize, setFrameSize] = useState({ width: 0, height: 0 });
        const fireTimer = useRef(null);
        const [sideToggle, setSideToggle] = useState(false);

        useEffect(() => {
          const resize = () => {
            const vw = window.innerWidth - 32;
            const vh = window.innerHeight - 32;
            const targetRatio = 16 / 9;
            let width = vw;
            let height = vw / targetRatio;
            if (height > vh) {
              height = vh;
              width = vh * targetRatio;
            }
            setFrameSize({ width, height });
          };
          resize();
          window.addEventListener('resize', resize);
          return () => window.removeEventListener('resize', resize);
        }, []);

        const spawnFloat = (x, y, side) => {
          const dmg = randInt(20, 30);
          const offsetX = (side ? 1 : -1) * randInt(80, 160);
          const jitterY = randInt(-10, 10);
          const lifeMs = 900 + randInt(-80, 120);
          setFloats((arr) => [
            ...arr,
            { id: Math.random(), x: x + offsetX, y: y + jitterY, value: dmg, bornAt: performance.now(), lifeMs }
          ]);
        };

        const attemptShoot = () => {
          if (!wrapRef.current || !overTarget) return;
          const rect = wrapRef.current.getBoundingClientRect();
          const humanoidW = rect.width * 0.35;
          const humanoidH = humanoidW * HUMANOID_ASPECT;
          const cx = rect.width / 2;
          const cy = rect.height * 0.6;
          const top = cy - humanoidH / 2;
          const headAnchorY = top + 10;
          spawnFloat(cx, headAnchorY, sideToggle);
          setSideToggle((s) => !s);
        };

        const startSustained = () => {
          if (fireTimer.current) return;
          attemptShoot();
          const interval = 1000 / 8; // ~8 shots/sec
          fireTimer.current = setInterval(attemptShoot, interval);
        };

        const stopSustained = () => {
          if (fireTimer.current) {
            clearInterval(fireTimer.current);
            fireTimer.current = null;
          }
        };

        useEffect(() => {
          const raf = requestAnimationFrame(function clean() {
            setFloats((arr) => arr.filter((f) => performance.now() - f.bornAt < f.lifeMs));
            requestAnimationFrame(clean);
          });
          return () => cancelAnimationFrame(raf);
        }, []);

        return (
          React.createElement('div', { className: 'min-h-screen w-full flex items-center justify-center bg-neutral-900 select-none' },
            React.createElement('div', {
              ref: wrapRef,
              style: { width: frameSize.width, height: frameSize.height },
              className: 'relative aspect-video rounded-2xl overflow-hidden shadow-2xl bg-gradient-to-b from-neutral-800 to-neutral-950',
              onPointerDown: (e) => { if (e.button === 0) { setIsDown(true); startSustained(); }},
              onPointerUp: () => { setIsDown(false); stopSustained(); },
              onPointerLeave: () => { setIsDown(false); stopSustained(); }
            },
              React.createElement('div', { className: 'absolute inset-0 flex flex-col items-center justify-end pb-[5%]' },
                React.createElement('div', { className: 'absolute inset-x-0 bottom-0 h-1/3 bg-gradient-to-t from-neutral-900/80 to-transparent' }),
                React.createElement('svg', {
                  className: 'w-[35%] drop-shadow-[0_12px_24px_rgba(0,0,0,0.5)]',
                  viewBox: '0 0 200 360', preserveAspectRatio: 'xMidYMax meet',
                },
                  React.createElement('g', {
                    onPointerEnter: () => setOverTarget(true),
                    onPointerLeave: () => setOverTarget(false),
                    style: { filter: overTarget ? 'brightness(1.25)' : 'none' }
                  },
                    React.createElement('defs', null,
                      React.createElement('linearGradient', { id: 'bodyGrad', x1: '0', x2: '0', y1: '0', y2: '1' },
                        React.createElement('stop', { offset: '0%', stopColor: '#6b7280' }),
                        React.createElement('stop', { offset: '100%', stopColor: '#374151' })
                      )
                    ),
                    React.createElement('circle', { cx: '100', cy: '40', r: '26', fill: 'url(#bodyGrad)' }),
                    React.createElement('rect', { x: '70', y: '72', width: '60', height: '82', rx: '10', fill: 'url(#bodyGrad)' }),
                    React.createElement('path', { d: 'M50 90 C60 85, 60 85, 70 92 V138 C60 142, 60 142, 50 134 Z', fill: 'url(#bodyGrad)' }),
                    React.createElement('path', { d: 'M150 90 C140 85, 140 85, 130 92 V138 C140 142, 140 142, 150 134 Z', fill: 'url(#bodyGrad)' }),
                    React.createElement('rect', { x: '80', y: '156', width: '40', height: '26', rx: '8', fill: 'url(#bodyGrad)' }),
                    React.createElement('rect', { x: '80', y: '184', width: '16', height: '80', rx: '8', fill: 'url(#bodyGrad)' }),
                    React.createElement('rect', { x: '104', y: '184', width: '16', height: '80', rx: '8', fill: 'url(#bodyGrad)' }),
                    React.createElement('rect', { x: '74', y: '264', width: '28', height: '12', rx: '6', fill: '#374151' }),
                    React.createElement('rect', { x: '98', y: '264', width: '28', height: '12', rx: '6', fill: '#374151' })
                  )
                )
              ),

              React.createElement(AnimatePresence, null,
                floats.map((f) => {
                  const progress = clamp((performance.now() - f.bornAt) / f.lifeMs, 0, 1);
                  const fontScale = 1 + ((f.value - 20) / 10) * 0.25;
                  const yOffset = -60 * Math.pow(progress, 0.8);
                  const xOffset = 12 * Math.sin(progress * Math.PI * 0.5);
                  return React.createElement('div', { key: f.id, className: 'pointer-events-none absolute', style: { left: f.x, top: f.y } },
                    React.createElement(motion.div || 'div', {
                      initial: { opacity: 0, scale: 0.6 },
                      animate: { opacity: [0, 1, 1, 0], scale: [0.6, 1.15 * fontScale, 1.0 * fontScale], x: xOffset, y: yOffset },
                      exit: { opacity: 0 },
                      transition: { duration: f.lifeMs / 1000 }
                    },
                      React.createElement('div', {
                        className: 'font-semibold',
                        style: { fontSize: `${Math.round(22 * fontScale)}px`, color: '#FFFFFF', textShadow: '0 2px 4px rgba(0,0,0,0.9), 0 0 8px rgba(0,0,0,0.6)', filter: 'drop-shadow(0 4px 12px rgba(0,0,0,0.6))' }
                      }, f.value)
                    )
                  );
                })
              ),

              React.createElement('div', { className: 'absolute inset-0 flex items-center justify-center pointer-events-none' },
                React.createElement('div', { className: 'relative w-14 h-14' },
                  React.createElement('div', { className: 'absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-[3px] h-[3px] bg-white rounded-full shadow-[0_0_8px_rgba(255,255,255,0.9)]' }),
                  React.createElement('div', { className: 'absolute inset-0 rounded-full border border-white/25' }),
                  React.createElement('div', { className: 'absolute inset-2 rounded-full border border-white/15' })
                )
              ),

              React.createElement('div', { className: 'absolute left-4 top-4 text-neutral-300/80 text-sm' }, 'LMB to shoot. Hold for sustained fire.')
            )
          )
        );
      }

      ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(FPSDamageNumbersMockup));
    </script>
  </body>
</html>
