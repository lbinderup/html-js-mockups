<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FPS Damage Numbers Mockup</title>
    
    <!-- 1. Tailwind CSS via Play CDN -->
    <!-- This script scans your HTML for Tailwind classes and applies the necessary styles. -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- 2. React & ReactDOM Libraries from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- 3. Framer Motion Library from CDN -->
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>

    <!-- 4. Babel Standalone for JSX Transpilation -->
    <!-- This transforms our JSX into regular JavaScript in the browser. -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      /* A little extra CSS to make sure the body fills the screen */
      body {
        margin: 0;
        font-family: sans-serif;
      }
    </style>
  </head>
  <body>
    <!-- The root element where our React app will be mounted -->
    <div id="root"></div>

    <!-- 5. Your React Code -->
    <!-- Note the type="text/babel" which tells Babel to transpile this script block. -->
    <script type="text/babel">
      // Because we loaded the libraries via CDN, they are available on the window object.
      // We destructure them to use them just like we would with imports.
      const { useEffect, useRef, useState } = React;
      const { motion, AnimatePresence } = FramerMotion;

      const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
      const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

      const HUMANOID_ASPECT = 360 / 200;

      // We removed "export default" because this is no longer a module.
      function FPSDamageNumbersMockup() {
        const wrapRef = useRef(null);
        const [floats, setFloats] = useState([]);
        const [isDown, setIsDown] = useState(false);
        const [overTarget, setOverTarget] = useState(false);
        const [frameSize, setFrameSize] = useState({ width: 0, height: 0 });
        const fireTimer = useRef(null);
        const [sideToggle, setSideToggle] = useState(false);

        useEffect(() => {
          const resize = () => {
            const vw = window.innerWidth - 32;
            const vh = window.innerHeight - 32;
            const targetRatio = 16 / 9;
            let width = vw;
            let height = vw / targetRatio;
            if (height > vh) {
              height = vh;
              width = vh * targetRatio;
            }
            setFrameSize({ width, height });
          };
          resize();
          window.addEventListener("resize", resize);
          return () => window.removeEventListener("resize", resize);
        }, []);

        const spawnFloat = (x, y, side) => {
          const dmg = randInt(20, 30);
          const offsetX = (side ? 1 : -1) * randInt(30, 80); // alternate horizontal spread
          const jitterY = randInt(-10, 10);
          const lifeMs = 900 + randInt(-80, 120);

          setFloats((arr) => [
            ...arr,
            {
              id: Math.random(),
              x: x + offsetX,
              y: y + jitterY,
              value: dmg,
              bornAt: performance.now(),
              lifeMs,
            },
          ]);
        };

        const attemptShoot = () => {
          if (!wrapRef.current || !overTarget) return;
          const rect = wrapRef.current.getBoundingClientRect();
          const humanoidW = rect.width * 0.35;
          const humanoidH = humanoidW * HUMANOID_ASPECT;
          const cx = rect.width / 2;
          const cy = rect.height * 0.6;
          const top = cy - humanoidH / 2;
          const headAnchorY = top + 10;
          spawnFloat(cx, headAnchorY, sideToggle);
          setSideToggle((s) => !s);
        };

        const startSustained = () => {
          if (fireTimer.current) return;
          attemptShoot();
          const interval = 1000 / 8; // ~8 shots/sec
          fireTimer.current = setInterval(attemptShoot, interval);
        };

        const stopSustained = () => {
          if (fireTimer.current) {
            clearInterval(fireTimer.current);
            fireTimer.current = null;
          }
        };

        useEffect(() => {
          const raf = requestAnimationFrame(function clean() {
            setFloats((arr) => arr.filter((f) => performance.now() - f.bornAt < f.lifeMs));
            requestAnimationFrame(clean);
          });
          return () => cancelAnimationFrame(raf);
        }, []);

        return (
          <div className="min-h-screen w-full flex items-center justify-center bg-neutral-900 select-none">
            <div
              ref={wrapRef}
              style={{ width: frameSize.width, height: frameSize.height }}
              className="relative aspect-video rounded-2xl overflow-hidden shadow-2xl bg-gradient-to-b from-neutral-800 to-neutral-950"
              onPointerDown={(e) => {
                if (e.button !== 0) return;
                setIsDown(true);
                startSustained();
              }}
              onPointerUp={() => {
                setIsDown(false);
                stopSustained();
              }}
              onPointerLeave={() => {
                setIsDown(false);
                stopSustained();
              }}
            >
              {/* Canvas content */}
              <div className="absolute inset-0 flex flex-col items-center justify-end pb-[5%]">
                <div className="absolute inset-x-0 bottom-0 h-1/3 bg-gradient-to-t from-neutral-900/80 to-transparent" />
                <svg
                  className="w-[35%] drop-shadow-[0_12px_24px_rgba(0,0,0,0.5)]"
                  viewBox="0 0 200 360"
                  preserveAspectRatio="xMidYMax meet"
                >
                  <g
                    onPointerEnter={() => setOverTarget(true)}
                    onPointerLeave={() => setOverTarget(false)}
                    style={{ filter: overTarget ? "brightness(1.25)" : "none" }}
                  >
                    <defs>
                      <linearGradient id="bodyGrad" x1="0" x2="0" y1="0" y2="1">
                        <stop offset="0%" stopColor="#6b7280" />
                        <stop offset="100%" stopColor="#374151" />
                      </linearGradient>
                    </defs>
                    <circle cx="100" cy="40" r="26" fill="url(#bodyGrad)" />
                    <rect x="70" y="72" width="60" height="82" rx="10" fill="url(#bodyGrad)" />
                    <path d="M50 90 C60 85, 60 85, 70 92 V138 C60 142, 60 142, 50 134 Z" fill="url(#bodyGrad)" />
                    <path d="M150 90 C140 85, 140 85, 130 92 V138 C140 142, 140 142, 150 134 Z" fill="url(#bodyGrad)" />
                    <rect x="80" y="156" width="40" height="26" rx="8" fill="url(#bodyGrad)" />
                    <rect x="80" y="184" width="16" height="80" rx="8" fill="url(#bodyGrad)" />
                    <rect x="104" y="184" width="16" height="80" rx="8" fill="url(#bodyGrad)" />
                    <rect x="74" y="264" width="28" height="12" rx="6" fill="#374151" />
                    <rect x="98" y="264" width="28" height="12" rx="6" fill="#374151" />
                  </g>
                </svg>
              </div>

              {/* Floating numbers */}
              <AnimatePresence>
                {floats.map((f) => {
                  const progress = clamp((performance.now() - f.bornAt) / f.lifeMs, 0, 1);
                  const fontScale = 1 + ((f.value - 20) / 10) * 0.25;
                  const yOffset = -60 * Math.pow(progress, 0.8);
                  const xOffset = 12 * Math.sin(progress * Math.PI * 0.5);
                  return (
                    <div key={f.id} className="pointer-events-none absolute" style={{ left: f.x, top: f.y }}>
                      <motion.div
                        initial={{ opacity: 0, scale: 0.6 }}
                        animate={{
                          opacity: [0, 1, 1, 0],
                          scale: [0.6, 1.15 * fontScale, 1.0 * fontScale],
                          x: xOffset,
                          y: yOffset,
                        }}
                        exit={{ opacity: 0 }}
                        transition={{ duration: f.lifeMs / 1000 }}
                      >
                        <div
                          className="font-semibold"
                          style={{
                            fontSize: `${Math.round(22 * fontScale)}px`,
                            color: "#FFFFFF",
                            textShadow: "0 2px 4px rgba(0,0,0,0.9), 0 0 8px rgba(0,0,0,0.6)",
                            filter: "drop-shadow(0 4px 12px rgba(0,0,0,0.6))",
                          }}
                        >
                          {f.value}
                        </div>
                      </motion.div>
                    </div>
                  );
                })}
              </AnimatePresence>

              {/* Reticle */}
              <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                <div className="relative w-14 h-14">
                  <div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-[3px] h-[3px] bg-white rounded-full shadow-[0_0_8px_rgba(255,255,255,0.9)]" />
                  <div className="absolute inset-0 rounded-full border border-white/25" />
                  <div className="absolute inset-2 rounded-full border border-white/15" />
                </div>
              </div>

              {/* Helper text */}
              <div className="absolute left-4 top-4 text-neutral-300/80 text-sm">LMB to shoot. Hold for sustained fire.</div>
            </div>
          </div>
        );
      }
      
      // 6. Tell React to render the component into the 'root' div.
      const container = document.getElementById('root');
      const root = ReactDOM.createRoot(container);
      root.render(<FPSDamageNumbersMockup />);

    </script>
  </body>
</html>
