<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AOE Telegraph – Wedge + Box</title>
<!-- Minimal styles, no Tailwind -->
<style>
  :root { --bg:#0a0a0a; --panel:#151515; --text:#eee; --muted:#9aa; --accent:#ff2d2d; }
  html,body { height:100%; margin:0; font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:var(--bg); color:var(--text); }
  .container { max-width:1100px; margin:0 auto; padding:24px; display:flex; flex-direction:column; gap:16px; }
  h1 { font-size:20px; margin:0 0 4px; }
  .panel { background:var(--panel); border-radius:16px; padding:16px; box-shadow: 0 2px 12px rgba(0,0,0,0.35); }
  .grid-2 { display:grid; grid-template-columns:1fr; gap:16px; }
  @media (min-width: 900px) { .grid-2 { grid-template-columns:1fr 1fr; } }
  .row { display:grid; grid-template-columns:1fr; gap:12px; }
  .controls { display:grid; grid-template-columns:1fr 1fr; gap:12px; }
  .controls-3 { display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px; }
  label { font-size:12px; color:var(--muted); display:block; margin-bottom:6px; }
  input[type=range] { width:100%; }
  .btn { background:#242424; color:var(--text); border:0; padding:8px 12px; border-radius:10px; cursor:pointer; }
  .btn:hover { background:#2d2d2d; }
  .subtle { font-size:12px; color:var(--muted); }
  svg { display:block; margin:0 auto; }
</style>
</head>
<body>
<div id="root"></div>

<!-- React via CDN + Babel for JSX in one file -->
<script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<script type="text/babel">
const {useEffect, useMemo, useRef, useState} = React;

function App() {
  // Shared windup
  const [durationMs, setDurationMs] = useState(2000);

  // Wedge controls
  const [wedgeAngleDeg, setWedgeAngleDeg] = useState(360);
  const [radius, setRadius] = useState(140);

  // Box controls
  const [boxW, setBoxW] = useState(220);
  const [boxH, setBoxH] = useState(140);

  // Visual tuning
  const idleStrokeWidth = 3;
  const runStrokeWidth = 6;
  const outlineColorRun = "#FF2D2D";
  const baseFill = "rgba(255,0,0,0.15)";
  const growFill = "rgba(255,0,0,0.45)";

  // Phases
  const [wedgePhase, setWedgePhase] = useState("idle");   // idle | running | flash
  const [boxPhase, setBoxPhase]     = useState("idle");

  // Progress
  const [wedgeProgress, setWedgeProgress] = useState(0);
  const [boxProgress, setBoxProgress]     = useState(0);

  // Animation refs
  const wedgeStartRef = useRef(null);
  const boxStartRef   = useRef(null);
  const wedgeFlashRef = useRef(null);
  const boxFlashRef   = useRef(null);

  // Helpers
  const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));
  const toRad = (deg) => (deg * Math.PI) / 180;

  // Wedge geometry
  const angle  = clamp(wedgeAngleDeg, 0, 360);
  const isFull = angle >= 360;
  const half   = angle / 2;
  const startDeg = -90 - half;
  const endDeg   = -90 + half;

  const wedgeSize = useMemo(() => radius * 2 + runStrokeWidth * 3, [radius]);
  const wcx = wedgeSize / 2;
  const wcy = wedgeSize / 2;

  function sectorPath(cx, cy, r, startDeg, endDeg) {
    const start = { x: cx + r * Math.cos(toRad(startDeg)), y: cy + r * Math.sin(toRad(startDeg)) };
    const end   = { x: cx + r * Math.cos(toRad(endDeg)),   y: cy + r * Math.sin(toRad(endDeg)) };
    const delta = Math.abs(endDeg - startDeg) % 360;
    const largeArc = delta > 180 ? 1 : 0;
    const sweep = endDeg > startDeg ? 1 : 0;
    return [
      `M ${cx} ${cy}`,
      `L ${start.x} ${start.y}`,
      `A ${r} ${r} 0 ${largeArc} ${sweep} ${end.x} ${end.y}`,
      "Z",
    ].join(" ");
  }

  // Box geometry
  const boxPadding = runStrokeWidth * 3;
  const boxSize = useMemo(() => Math.max(boxW, boxH) + boxPadding * 2, [boxW, boxH]);
  const bcx = boxSize / 2;
  const bcy = boxSize / 2;
  const boxX = bcx - boxW / 2;
  const boxY = bcy - boxH / 2;

  // Wedge animation
  useEffect(() => {
    if (wedgePhase !== "running") return;
    let raf = 0;
    const tick = (t) => {
      if (wedgeStartRef.current == null) wedgeStartRef.current = t;
      const p = Math.min(1, (t - wedgeStartRef.current) / Math.max(1, durationMs));
      setWedgeProgress(p);
      if (p >= 1) {
        setWedgePhase("flash");
        wedgeStartRef.current = null;
        if (wedgeFlashRef.current) window.clearTimeout(wedgeFlashRef.current);
        wedgeFlashRef.current = window.setTimeout(() => {
          setWedgeProgress(0);
          setWedgePhase("idle");
        }, 200);
        return;
      }
      raf = requestAnimationFrame(tick);
    };
    raf = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(raf);
  }, [wedgePhase, durationMs]);

  // Box animation
  useEffect(() => {
    if (boxPhase !== "running") return;
    let raf = 0;
    const tick = (t) => {
      if (boxStartRef.current == null) boxStartRef.current = t;
      const p = Math.min(1, (t - boxStartRef.current) / Math.max(1, durationMs));
      setBoxProgress(p);
      if (p >= 1) {
        setBoxPhase("flash");
        boxStartRef.current = null;
        if (boxFlashRef.current) window.clearTimeout(boxFlashRef.current);
        boxFlashRef.current = window.setTimeout(() => {
          setBoxProgress(0);
          setBoxPhase("idle");
        }, 200);
        return;
      }
      raf = requestAnimationFrame(tick);
    };
    raf = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(raf);
  }, [boxPhase, durationMs]);

  useEffect(() => () => {
    if (wedgeFlashRef.current) window.clearTimeout(wedgeFlashRef.current);
    if (boxFlashRef.current) window.clearTimeout(boxFlashRef.current);
  }, []);

  // Handlers
  const playPauseWedge = () => {
    if (wedgePhase === "running") {
      setWedgePhase("idle"); setWedgeProgress(0); wedgeStartRef.current = null;
    } else {
      setWedgeProgress(0); wedgeStartRef.current = null; setWedgePhase("running");
    }
  };
  const resetWedge = () => { setWedgePhase("idle"); setWedgeProgress(0); wedgeStartRef.current = null; };

  const playPauseBox = () => {
    if (boxPhase === "running") {
      setBoxPhase("idle"); setBoxProgress(0); boxStartRef.current = null;
    } else {
      setBoxProgress(0); boxStartRef.current = null; setBoxPhase("running");
    }
  };
  const resetBox = () => { setBoxPhase("idle"); setBoxProgress(0); boxStartRef.current = null; };

  // Outlines
  const WedgeIdleOutline = () => (
    isFull ? (
      <circle cx={wcx} cy={wcy} r={radius} fill="none" stroke="#FFFFFF" strokeOpacity="0.9" strokeWidth={idleStrokeWidth} strokeDasharray="6 8" strokeLinecap="round" />
    ) : (
      <g>
        <path
          d={`M ${wcx + radius * Math.cos(toRad(startDeg))} ${wcy + radius * Math.sin(toRad(startDeg))} A ${radius} ${radius} 0 ${Math.abs(endDeg - startDeg) > 180 ? 1 : 0} ${endDeg > startDeg ? 1 : 0} ${wcx + radius * Math.cos(toRad(endDeg))} ${wcy + radius * Math.sin(toRad(endDeg))}`}
          fill="none" stroke="#FFFFFF" strokeOpacity="0.9" strokeWidth={idleStrokeWidth} strokeDasharray="6 8" strokeLinecap="round"
        />
        <line x1={wcx} y1={wcy} x2={wcx + radius * Math.cos(toRad(startDeg))} y2={wcy + radius * Math.sin(toRad(startDeg))} stroke="#FFFFFF" strokeOpacity="0.9" strokeWidth={idleStrokeWidth} strokeDasharray="6 8" strokeLinecap="round" />
        <line x1={wcx} y1={wcy} x2={wcx + radius * Math.cos(toRad(endDeg))} y2={wcy + radius * Math.sin(toRad(endDeg))} stroke="#FFFFFF" strokeOpacity="0.9" strokeWidth={idleStrokeWidth} strokeDasharray="6 8" strokeLinecap="round" />
      </g>
    )
  );

  const WedgeRunOutline = () => (
    isFull ? (
      <circle cx={wcx} cy={wcy} r={radius} fill="none" stroke={outlineColorRun} strokeWidth={runStrokeWidth} />
    ) : (
      <g>
        <path
          d={`M ${wcx + radius * Math.cos(toRad(startDeg))} ${wcy + radius * Math.sin(toRad(startDeg))} A ${radius} ${radius} 0 ${Math.abs(endDeg - startDeg) > 180 ? 1 : 0} ${endDeg > startDeg ? 1 : 0} ${wcx + radius * Math.cos(toRad(endDeg))} ${wcy + radius * Math.sin(toRad(endDeg))}`}
          fill="none" stroke={outlineColorRun} strokeWidth={runStrokeWidth} strokeLinecap="round"
        />
        <line x1={wcx} y1={wcy} x2={wcx + radius * Math.cos(toRad(startDeg))} y2={wcy + radius * Math.sin(toRad(startDeg))} stroke={outlineColorRun} strokeWidth={runStrokeWidth} strokeLinecap="round" />
        <line x1={wcx} y1={wcy} x2={wcx + radius * Math.cos(toRad(endDeg))} y2={wcy + radius * Math.sin(toRad(endDeg))} stroke={outlineColorRun} strokeWidth={runStrokeWidth} strokeLinecap="round" />
      </g>
    )
  );

  const BoxIdleOutline = () => (
    <rect x={boxX} y={boxY} width={boxW} height={boxH} fill="none" stroke="#FFFFFF" strokeOpacity="0.9" strokeWidth={idleStrokeWidth} strokeDasharray="6 8" strokeLinecap="round" />
  );

  const BoxRunOutline = () => (
    <rect x={boxX} y={boxY} width={boxW} height={boxH} fill="none" stroke={outlineColorRun} strokeWidth={runStrokeWidth} />
  );

  // Derived grows
  const currentWedgeR = Math.max(0, radius * wedgeProgress);
  const currentBoxH   = Math.max(0, boxH * boxProgress);
  const boxGrowY      = boxY + (boxH - currentBoxH); // bottom-up

  return (
    <div className="container">
      <div className="row">
        <h1>AOE Telegraph – Wedge + Box</h1>
        <div className="panel">
          <label>Windup Duration (ms): {durationMs}</label>
          <input type="range" min="250" max="6000" step="50" value={durationMs}
                 onChange={(e) => setDurationMs(Number(e.target.value))} />
        </div>
      </div>

      <div className="grid-2">
        <div className="panel">
          <div style={{display:'flex',justifyContent:'space-between',alignItems:'baseline',marginBottom:8}}>
            <h2 style={{margin:0,fontSize:16}}>Wedge / Circle</h2>
            <div className="subtle">Idle: dotted. Play: red. End: flash.</div>
          </div>

          <div className="controls" style={{marginBottom:12}}>
            <div>
              <label>Wedge Angle (°): {angle}</label>
              <input type="range" min="5" max="360" step="5" value={angle}
                     onChange={(e) => setWedgeAngleDeg(Number(e.target.value))} />
            </div>
            <div style={{display:'flex',gap:8,alignItems:'end'}}>
              <button className="btn" onClick={playPauseWedge} aria-label={wedgePhase === "running" ? "Pause" : "Play"}>
                {wedgePhase === "running" ? "Pause" : "Play"}
              </button>
              <button className="btn" onClick={resetWedge}>Reset</button>
            </div>
          </div>

          <svg width={wedgeSize} height={wedgeSize}>
            {wedgePhase === "idle" && <WedgeIdleOutline />}
            {wedgePhase === "running" && (
              <>
                {isFull ? (
                  <circle cx={wcx} cy={wcy} r={radius} fill={baseFill} />
                ) : (
                  <path d={sectorPath(wcx, wcy, radius, startDeg, endDeg)} fill={baseFill} />
                )}
                {currentWedgeR > 0 && (isFull ? (
                  <circle cx={wcx} cy={wcy} r={currentWedgeR} fill={growFill} />
                ) : (
                  <path d={sectorPath(wcx, wcy, currentWedgeR, startDeg, endDeg)} fill={growFill} />
                ))}
                <WedgeRunOutline />
              </>
            )}
            {wedgePhase === "flash" && (isFull ? (
              <circle cx={wcx} cy={wcy} r={radius} fill="#FFFFFF" opacity="0.98" />
            ) : (
              <path d={sectorPath(wcx, wcy, radius, startDeg, endDeg)} fill="#FFFFFF" opacity="0.98" />
            ))}
          </svg>
        </div>

        <div className="panel">
          <div style={{display:'flex',justifyContent:'space-between',alignItems:'baseline',marginBottom:8}}>
            <h2 style={{margin:0,fontSize:16}}>Box</h2>
            <div className="subtle">Bottom-up fill.</div>
          </div>

          <div className="controls-3" style={{marginBottom:12}}>
            <div>
              <label>Width: {Math.round(boxW)}px</label>
              <input type="range" min="60" max="320" step="5" value={boxW}
                     onChange={(e) => setBoxW(Number(e.target.value))} />
            </div>
            <div>
              <label>Height (depth): {Math.round(boxH)}px</label>
              <input type="range" min="60" max="320" step="5" value={boxH}
                     onChange={(e) => setBoxH(Number(e.target.value))} />
            </div>
            <div style={{display:'flex',gap:8,alignItems:'end'}}>
              <button className="btn" onClick={playPauseBox} aria-label={boxPhase === "running" ? "Pause" : "Play"}>
                {boxPhase === "running" ? "Pause" : "Play"}
              </button>
              <button className="btn" onClick={resetBox}>Reset</button>
            </div>
          </div>

          <svg width={boxSize} height={boxSize}>
            {boxPhase === "idle" && <BoxIdleOutline />}
            {boxPhase === "running" && (
              <>
                <rect x={boxX} y={boxY} width={boxW} height={boxH} fill={baseFill} />
                {currentBoxH > 0 && (
                  <rect x={boxX} y={boxGrowY} width={boxW} height={currentBoxH} fill={growFill} />
                )}
                <BoxRunOutline />
              </>
            )}
            {boxPhase === "flash" && (
              <rect x={boxX} y={boxY} width={boxW} height={boxH} fill="#FFFFFF" opacity="0.98" />
            )}
          </svg>
        </div>
      </div>

      <div className="subtle">
        Shared windup controls both. Each shape has independent play/reset. Idle is dotted. Finish flashes 200ms, then resets.
      </div>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
</script>
</body>
</html>
