<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ability Icon Mockup â€“ Reactive</title>
  <style>
    :root { --size: 240px; }
    html, body { height: 100%; margin: 0; background: #0b0b0f; display: grid; place-items: center; }
    .wrap { position: relative; width: var(--size); height: var(--size); }

    /* Main icon holder that we scale on activate */
    .icon { position: absolute; inset: 0; display: grid; place-items: center; transform-origin: 50% 50%; }

    /* Press animation: shrink to 90% for 0.25s then back */
    .icon.pressing { animation: pressScale 150ms ease-in-out; }
    @keyframes pressScale {
      0% { transform: scale(1); }
      50% { transform: scale(0.9); }
      100% { transform: scale(1); }
    }

    /* Ready ripple spawned on recharge completion */
    .ripple { position: absolute; inset: 0; pointer-events: none; opacity: 0.85; transform-origin: 50% 50%; }
    .ripple.animate { animation: ripple 360ms ease-out forwards; }
    @keyframes ripple {
      0%   { transform: scale(1);   opacity: 0.85; }
      100% { transform: scale(1.35); opacity: 0; }
    }

    svg { width: 100%; height: 100%; display: block; }
    .hint { position: absolute; bottom: -28px; width: 100%; text-align: center; font: 12px/1.2 system-ui, sans-serif; color: #9aa0a6; user-select: none; }
  </style>
</head>
<body>
  <div class="wrap" id="wrap">
    <!-- Ripple container; we inject temporary SVGs here -->
    <div id="ripples"></div>

    <div class="icon" id="icon">
      <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
        <!-- Clip from bottom for the solid refill layer -->
        <clipPath id="refillClip">
          <rect id="refillRect" x="0" y="100" width="100" height="0" />
        </clipPath>

        <!-- Combined path: hexagon with vertically centered explosion cutout (evenodd) -->
        <defs>
          <!-- Explosion moved up ~4 units for visual centering -->
          <path id="hexExplosion" d="M50 5 L93 27.5 L93 72.5 L50 95 L7 72.5 L7 27.5 Z
             M50 26 L55 41 L70 36 L60 51 L70 66 L55 61 L50 76 L45 61 L30 66 L40 51 L30 36 L45 41 Z"
             fill-rule="evenodd" clip-rule="evenodd" />
        </defs>

        <!-- Low-opacity background layer (persistent 25% once drained). No stroke. -->
        <use id="bg25" href="#hexExplosion" fill="white" opacity="1" />

        <!-- Solid white refill layer, revealed from bottom by clip. No stroke. -->
        <use id="solidRefill" href="#hexExplosion" fill="white" clip-path="url(#refillClip)" />
      </svg>
    </div>

    <div class="hint">press Space</div>
  </div>

  <script>
    const wrap = document.getElementById('wrap');
    const icon = document.getElementById('icon');
    const ripples = document.getElementById('ripples');

    // Access elements inside the SVG
    const refillRect = document.getElementById('refillRect');
    const bg25       = document.getElementById('bg25');
    const solidRefill= document.getElementById('solidRefill');

    const DRAIN_TIME = 150;           // ms to drain to 25%
    const REFILL_TIME = 4000;         // ms to refill solid from bottom

    let busy = false;
    let state = 'ready'; // 'ready' | 'drained' | 'refilling'

    // --- Simple WebAudio Synth ---
    let audioCtx = null;
    let master = null;

    function initAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      master = audioCtx.createGain();
      master.gain.value = 0.12; // overall volume
      master.connect(audioCtx.destination);
    }

    function beep({freq=440, type='sine', dur=0.12, attack=0.002, release=0.08, when=0}) {
      const t0 = (audioCtx ? audioCtx.currentTime : 0) + when;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(0, t0);
      g.gain.linearRampToValueAtTime(1, t0 + attack);
      g.gain.linearRampToValueAtTime(0, t0 + dur);
      osc.connect(g).connect(master);
      osc.start(t0);
      osc.stop(t0 + dur + release);
    }

    function clickSound() {
      // short high click + lower thump
      beep({freq: 1200, type: 'square', dur: 0.04, attack: 0.001, release: 0.03});
      beep({freq: 240, type: 'sine',   dur: 0.06, attack: 0.001, release: 0.04, when: 0.0});
    }

    function errorSound() {
      // two quick low beeps
      beep({freq: 220, type: 'sawtooth', dur: 0.06});
      beep({freq: 170, type: 'sawtooth', dur: 0.06, when: 0.08});
    }

    function readyChime() {
      // simple arpeggio C5-E5-G5
      beep({freq: 523.25, type: 'triangle', dur: 0.10});
      beep({freq: 659.25, type: 'triangle', dur: 0.10, when: 0.09});
      beep({freq: 783.99, type: 'triangle', dur: 0.12, when: 0.18});
    }

    function setRefillProgress(p) {
      const height = 100 * p;
      const y = 100 - height;
      refillRect.setAttribute('y', y.toFixed(3));
      refillRect.setAttribute('height', height.toFixed(3));
    }

    function drainTo25() {
      return new Promise((resolve) => {
        const start = performance.now();
        const startOpacity = parseFloat(bg25.getAttribute('opacity')) || 1;
        const endOpacity = 0.25;
        function step(now) {
          const t = Math.min(1, (now - start) / DRAIN_TIME);
          const o = startOpacity + (endOpacity - startOpacity) * t;
          bg25.setAttribute('opacity', o.toFixed(3));
          if (t < 1) requestAnimationFrame(step); else resolve();
        }
        requestAnimationFrame(step);
      });
    }

    function animateRefill() {
      return new Promise((resolve) => {
        const start = performance.now();
        function step(now) {
          const t = Math.min(1, (now - start) / REFILL_TIME);
          setRefillProgress(t);
          if (t < 1) requestAnimationFrame(step); else resolve();
        }
        requestAnimationFrame(step);
      });
    }

    function pulseFillRed() {
      const oldBg = bg25.getAttribute('fill') || 'white';
      const oldSolid = solidRefill.getAttribute('fill') || 'white';
      bg25.setAttribute('fill', '#ff2b2b');
      solidRefill.setAttribute('fill', '#ff2b2b');
      setTimeout(() => {
        bg25.setAttribute('fill', oldBg);
        solidRefill.setAttribute('fill', oldSolid);
      }, 70);
    }

    function animatePress() {
      icon.classList.remove('pressing');
      void icon.offsetWidth; // restart animation
      icon.classList.add('pressing');
    }

    function spawnReadyRipple() {
      // Build a minimal standalone SVG so we avoid ID collisions
      const svgNS = 'http://www.w3.org/2000/svg';
      const s = document.createElementNS(svgNS, 'svg');
      s.setAttribute('viewBox', '0 0 100 100');
      s.classList.add('ripple', 'animate');

      const p = document.createElementNS(svgNS, 'path');
      p.setAttribute('d', 'M50 5 L93 27.5 L93 72.5 L50 95 L7 72.5 L7 27.5 Z M50 26 L55 41 L70 36 L60 51 L70 66 L55 61 L50 76 L45 61 L30 66 L40 51 L30 36 L45 41 Z');
      p.setAttribute('fill', 'white');
      p.setAttribute('fill-rule', 'evenodd');
      p.setAttribute('clip-rule', 'evenodd');
      s.appendChild(p);

      ripples.appendChild(s);
      s.addEventListener('animationend', () => s.remove());
    }

    async function triggerCycle() {
      if (busy) return; // animation in progress
      busy = true;

      if (state === 'ready') {
        initAudio();
        clickSound();
        animatePress();
        await drainTo25();
        setRefillProgress(0);
        state = 'drained';
        state = 'refilling';
        await animateRefill();
        bg25.setAttribute('opacity', '1');
        state = 'ready';
        spawnReadyRipple();
        readyChime();
      }

      busy = false;
    }

    function attemptActivate() {
      initAudio();
      if (state !== 'ready' || busy) {
        pulseFillRed();
        errorSound();
        return;
      }
      triggerCycle();
    }

    // Initialize graphic to fully filled
    setRefillProgress(1);

    // Keyboard: Space to trigger
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.key === ' ') {
        e.preventDefault();
        attemptActivate();
      }
    });

    // Click also triggers
    wrap.addEventListener('click', attemptActivate);
  </script>
</body>
</html>
