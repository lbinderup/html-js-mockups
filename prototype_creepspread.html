<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"
  />
  <title>Organic Creep Spread</title>
  <style>
    :root {
      --sand: #d9c7a3;
      --sand-dark: #cbb68c;
      --purple: #7a2cff;
      --ui: rgba(20, 20, 24, 0.85);
      --ui2: rgba(255, 255, 255, 0.14);
      --text: rgba(255, 255, 255, 0.92);
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #0f0f12;
      overflow: hidden;
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      user-select: none;
      -webkit-user-select: none;
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      touch-action: none;
    }
    .hud {
      position: absolute;
      left: 12px;
      right: 12px;
      top: 12px;
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      pointer-events: none;
    }
    .panel {
      pointer-events: auto;
      background: var(--ui);
      color: var(--text);
      border: 1px solid var(--ui2);
      border-radius: 12px;
      padding: 10px 14px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    button {
      pointer-events: auto;
      border: 1px solid var(--ui2);
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
    }
    button:active { transform: translateY(1px); }
    .hint { font-size: 12px; opacity: 0.8; max-width: 250px; line-height: 1.4; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="panel">
      <button id="toggle">Retract: OFF</button>
      <div style="font-size:12px; opacity:0.8" id="stats">Active Cells: 0</div>
    </div>
    <div class="panel hint">
      Tap to spawn <strong>Root Network</strong>.<br/>
      Roots expand rapidly. Gaps fill slowly.<br/>
      Retract peels edges back.
    </div>
  </div>

  <script>
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp  = (a, b, t) => a + (b - a) * t;

    // ---- Utils ----
    function hexToRgb(hex) {
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return m ? { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16) } : { r:0,g:0,b:0 };
    }
    function mixRgb(a, b, t) {
      return { 
        r: Math.round(lerp(a.r,b.r,t)), 
        g: Math.round(lerp(a.g,b.g,t)), 
        b: Math.round(lerp(a.b,b.b,t)) 
      };
    }

    // ---- Grid & Graph ----
    const TRI_SIZE = 26;
    const GRID_W = 70; 
    const GRID_H = 70;
    const h = TRI_SIZE * Math.sqrt(3) * 0.5;
    const mapWidth  = GRID_W * TRI_SIZE;
    const mapHeight = GRID_H * (2 * h);

    const triangles = []; 
    const spatialGrid = new Map(); 

    function getSpatialKey(x, y) {
      const gX = Math.floor(x / TRI_SIZE);
      const gY = Math.floor(y / TRI_SIZE);
      return `${gX},${gY}`;
    }

    function buildGraph() {
      triangles.length = 0;
      spatialGrid.clear();

      // 1. Generate Geometry
      let idCounter = 0;
      for (let y = 0; y < GRID_H; y++) {
        for (let x = 0; x < GRID_W; x++) {
          const ox = x * TRI_SIZE + ((y % 2) * (TRI_SIZE * 0.5));
          const oy = y * (2 * h);
          
          const p0 = { x: ox,                 y: oy };
          const p1 = { x: ox + TRI_SIZE,      y: oy };
          const p2 = { x: ox + TRI_SIZE*0.5,  y: oy + 2*h };
          const p3 = { x: ox - TRI_SIZE*0.5,  y: oy + 2*h };

          // Tri 1 (Pointing Down)
          createTri(p0, p1, p2, idCounter++);
          // Tri 2 (Pointing Up)
          createTri(p0, p2, p3, idCounter++);
        }
      }

      // 2. Link Neighbors
      const neighborDist = (TRI_SIZE * Math.sqrt(3) / 3) * 2.1; 
      
      for (let i = 0; i < triangles.length; i++) {
        const t = triangles[i];
        const sx = Math.floor(t.cx / TRI_SIZE);
        const sy = Math.floor(t.cy / TRI_SIZE);
        
        for(let nx = sx-1; nx <= sx+1; nx++) {
          for(let ny = sy-1; ny <= sy+1; ny++) {
            const key = `${nx},${ny}`;
            const bucket = spatialGrid.get(key);
            if(!bucket) continue;
            
            for(const other of bucket) {
              if (other === t) continue;
              const d = (t.cx - other.cx)**2 + (t.cy - other.cy)**2;
              if (d < neighborDist * neighborDist) {
                t.neighbors.push(other);
              }
            }
          }
        }
      }
    }

    function createTri(a, b, c, id) {
      const cx = (a.x + b.x + c.x) / 3;
      const cy = (a.y + b.y + c.y) / 3;
      const path = new Path2D();
      path.moveTo(a.x, a.y);
      path.lineTo(b.x, b.y);
      path.lineTo(c.x, c.y);
      path.closePath();

      const tri = {
        id, a, b, c, cx, cy, path,
        neighbors: [],
        creep: 0,       
        state: 0,       
        noiseOffset: Math.random() 
      };
      
      triangles.push(tri);
      
      const key = getSpatialKey(cx, cy);
      if(!spatialGrid.has(key)) spatialGrid.set(key, []);
      spatialGrid.get(key).push(tri);
    }

    // ---- Creep Systems ----
    const walkers = [];

    class Walker {
      constructor(startTri, dirVec, life, thickness) {
        this.currentTri = startTri;
        this.dir = dirVec; 
        this.life = life;
        this.thickness = thickness; 
        this.mark(startTri);
      }

      update() {
        if (this.life <= 0 || !this.currentTri) return false;

        let bestDot = -2;
        let nextTri = null;

        for (const n of this.currentTri.neighbors) {
          const dx = n.cx - this.currentTri.cx;
          const dy = n.cy - this.currentTri.cy;
          const len = Math.hypot(dx, dy);
          const dot = (dx/len) * this.dir.x + (dy/len) * this.dir.y;
          const noise = (Math.random() - 0.5) * 0.5;
          
          if (dot + noise > bestDot) {
            bestDot = dot + noise;
            nextTri = n;
          }
        }

        if (nextTri) {
          this.currentTri = nextTri;
          this.mark(nextTri);
          
          if (this.life > 5 && Math.random() < 0.15) {
            const angle = Math.atan2(this.dir.y, this.dir.x);
            const newAngle = angle + (Math.random() < 0.5 ? 0.8 : -0.8);
            const newDir = { x: Math.cos(newAngle), y: Math.sin(newAngle) };
            walkers.push(new Walker(this.currentTri, newDir, this.life * 0.6, this.thickness * 0.8));
          }
        } else {
          this.life = 0;
        }

        this.life--;
        return true;
      }

      mark(tri) {
        tri.creep = 1.0;
        tri.state = 2; 
        if (this.thickness > 1.5) {
          for (const n of tri.neighbors) {
             n.creep = Math.max(n.creep, 0.8);
             n.state = 2; 
          }
        }
      }
    }

    function spawnSource(x, y) {
      let bestDist = 99999;
      let startTri = null;
      
      // Brute force nearest search (fast enough for click events)
      for(const t of triangles) {
        const d = (t.cx - x)**2 + (t.cy - y)**2;
        if (d < bestDist) { bestDist = d; startTri = t; }
      }

      if (startTri && bestDist < 2500) {
        for(let i=0; i<6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          const dir = { x: Math.cos(angle), y: Math.sin(angle) };
          const life = 15 + Math.random() * 15; 
          walkers.push(new Walker(startTri, dir, life, 2.0));
        }
      }
    }

    // ---- Main Loop ----
    let retractMode = false;
    
    const cam = { x: mapWidth/2, y: mapHeight/2, scale: 0.6 };
    let DPR = 1;
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha: false });
    
    const sand = hexToRgb(getComputedStyle(document.documentElement).getPropertyValue("--sand").trim());
    const sandDark = hexToRgb(getComputedStyle(document.documentElement).getPropertyValue("--sand-dark").trim());
    const purple = hexToRgb(getComputedStyle(document.documentElement).getPropertyValue("--purple").trim());

    function screenToWorld(sx, sy) {
      const rect = canvas.getBoundingClientRect();
      const x = (sx - rect.width  * 0.5) / cam.scale + cam.x;
      const y = (sy - rect.height * 0.5) / cam.scale + cam.y;
      return { x, y };
    }

    function clampCamera() {
      const rect = canvas.getBoundingClientRect();
      const halfW = rect.width  * 0.5 / cam.scale;
      const halfH = rect.height * 0.5 / cam.scale;
      const pad = 100;
      cam.x = clamp(cam.x, -pad + halfW, mapWidth + pad - halfW);
      cam.y = clamp(cam.y, -pad + halfH, mapHeight + pad - halfH);
      cam.scale = clamp(cam.scale, 0.25, 3.0);
    }
    
    function resize() {
      DPR = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * DPR;
      canvas.height = window.innerHeight * DPR;
      canvas.style.width = window.innerWidth + "px";
      canvas.style.height = window.innerHeight + "px";
      clampCamera();
    }

    function draw() {
      const rect = canvas.getBoundingClientRect();
      
      // BG - FIX: Use canvas.width/height (Physical Pixels) instead of rect (CSS Pixels)
      // because setTransform is Identity here.
      ctx.setTransform(1,0,0,1,0,0);
      ctx.fillStyle = "#0f0f12";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // World Transform
      const sx = cam.scale * DPR;
      const sy = cam.scale * DPR;
      const tx = (rect.width * 0.5 - cam.x * cam.scale) * DPR;
      const ty = (rect.height * 0.5 - cam.y * cam.scale) * DPR;
      ctx.setTransform(sx, 0, 0, sy, tx, ty);

      // Culling
      const viewMin = screenToWorld(0, 0);
      const viewMax = screenToWorld(rect.width, rect.height);
      const minX = Math.min(viewMin.x, viewMax.x) - 50;
      const minY = Math.min(viewMin.y, viewMax.y) - 50;
      const maxX = Math.max(viewMin.x, viewMax.x) + 50;
      const maxY = Math.max(viewMin.y, viewMax.y) + 50;

      let activeCount = 0;

      for (const tri of triangles) {
        if (tri.cx < minX || tri.cx > maxX || tri.cy < minY || tri.cy > maxY) continue;
        
        const c = tri.creep;
        if (c > 0.01) {
          activeCount++;
          const base = mixRgb(sand, sandDark, tri.noiseOffset);
          const finalCol = mixRgb(base, purple, c);
          
          ctx.fillStyle = `rgb(${finalCol.r},${finalCol.g},${finalCol.b})`;
          ctx.fill(tri.path);
        } else {
          // UX FIX: Draw faint grid so the user knows where the map is
          ctx.strokeStyle = "#1a1a1f";
          // Scale linewidth down when zoomed in so lines stay crisp
          ctx.lineWidth = 1 / Math.max(0.1, cam.scale);
          ctx.stroke(tri.path);
        }
      }
      
      if (Math.random() < 0.05) {
         document.getElementById("stats").textContent = `Active Cells: ${activeCount}`;
      }
    }

    let lastTime = 0;
    
    function step(time) {
      const dt = Math.min(0.06, (time - lastTime) / 1000);
      lastTime = time;

      // 1. Update Walkers
      for (let i = walkers.length - 1; i >= 0; i--) {
        if (!walkers[i].update()) {
          walkers.splice(i, 1);
        }
      }

      // 2. Slow Fill
      const growthRate = 2.0 * dt; 
      const decayRate = 3.5 * dt;

      for (const t of triangles) {
        
        if (retractMode) {
           if (t.creep > 0) {
             let exposed = false;
             for(const n of t.neighbors) {
               if(n.creep < 0.2) {
                 exposed = true; 
                 break;
               }
             }
             
             if(exposed) {
               t.creep -= decayRate;
               if(t.creep <= 0) {
                 t.creep = 0;
                 t.state = 0;
               }
             }
           }
        } 
        else {
          if (t.state === 2) {
             t.creep = 1; 
          } 
          else {
            if (t.creep >= 1.0) {
              t.state = 2; 
            } else {
              let maxNeighbor = 0;
              for (const n of t.neighbors) {
                if (n.creep > maxNeighbor) maxNeighbor = n.creep;
              }
              
              if (maxNeighbor > 0.4) {
                const speed = (maxNeighbor > 0.9) ? growthRate : (growthRate * 0.3);
                t.creep += speed;
                t.state = 1; 
              }
            }
          }
        }
      }

      draw();
      requestAnimationFrame(step);
    }

    // ---- Input ----
    const pointers = new Map();
    let isDragging = false;
    let lastDragWorld = null;
    let tapCandidate = null;

    canvas.addEventListener("pointerdown", (e) => {
      canvas.setPointerCapture(e.pointerId); // Better drag handling
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      tapCandidate = { id: e.pointerId, sx: e.clientX, sy: e.clientY, time: performance.now(), moved: false };
      if (pointers.size === 1) {
        isDragging = true;
        lastDragWorld = screenToWorld(e.clientX, e.clientY);
      }
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!pointers.has(e.pointerId)) return;
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      
      if (tapCandidate && tapCandidate.id === e.pointerId) {
        const d = Math.hypot(e.clientX - tapCandidate.sx, e.clientY - tapCandidate.sy);
        if (d > 10) tapCandidate.moved = true;
      }

      if (pointers.size === 1 && isDragging) {
        const w = screenToWorld(e.clientX, e.clientY);
        cam.x += (lastDragWorld.x - w.x);
        cam.y += (lastDragWorld.y - w.y);
        // Recalculate lastDragWorld because cam changed
        lastDragWorld = screenToWorld(e.clientX, e.clientY); 
        clampCamera();
      }

      if (pointers.size === 2) {
        const pts = Array.from(pointers.values());
        const p0 = pts[0], p1 = pts[1];
        const mid = { x: (p0.x + p1.x)*0.5, y: (p0.y + p1.y)*0.5 };
        const dist = Math.hypot(p1.x-p0.x, p1.y-p0.y);

        if (!canvas._pinch) {
          canvas._pinch = { d: dist, s: cam.scale, mid: screenToWorld(mid.x, mid.y) };
        } else {
          const zoom = dist / canvas._pinch.d;
          cam.scale = clamp(canvas._pinch.s * zoom, 0.25, 3.0);
          const nowWorld = screenToWorld(mid.x, mid.y);
          cam.x += (canvas._pinch.mid.x - nowWorld.x);
          cam.y += (canvas._pinch.mid.y - nowWorld.y);
          clampCamera();
        }
      }
    });

    canvas.addEventListener("pointerup", (e) => {
      pointers.delete(e.pointerId);
      if (pointers.size < 2) canvas._pinch = null;
      if (pointers.size === 0) isDragging = false;
      
      if (tapCandidate && tapCandidate.id === e.pointerId && !tapCandidate.moved) {
        if (performance.now() - tapCandidate.time < 300) {
          const w = screenToWorld(e.clientX, e.clientY);
          spawnSource(w.x, w.y);
        }
      }
      tapCandidate = null;
    });

    document.getElementById("toggle").addEventListener("click", () => {
      retractMode = !retractMode;
      document.getElementById("toggle").textContent = `Retract: ${retractMode ? "ON" : "OFF"}`;
    });

    window.addEventListener("resize", resize);

    buildGraph();
    resize();
    requestAnimationFrame(step);

  </script>
</body>
</html>
