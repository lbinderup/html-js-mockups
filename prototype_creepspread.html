<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"
  />
  <title>Organic Creep Spread Prototype</title>
  <style>
    :root {
      --sand: #d9c7a3;
      --sand-dark: #cbb68c;
      --purple: #7a2cff;
      --ui: rgba(20, 20, 24, 0.82);
      --ui2: rgba(255, 255, 255, 0.14);
      --text: rgba(255, 255, 255, 0.92);
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #0f0f12;
      overflow: hidden;
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      user-select: none;
      -webkit-user-select: none;
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100vw;
      height: 100vh;
      touch-action: none;
      display: block;
    }
    .hud {
      position: absolute;
      left: 12px;
      right: 12px;
      top: 12px;
      display: flex;
      gap: 10px;
      align-items: flex-start;
      justify-content: space-between;
      pointer-events: none;
    }
    .panel {
      pointer-events: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      background: var(--ui);
      color: var(--text);
      border: 1px solid var(--ui2);
      border-radius: 14px;
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    .row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    button {
      pointer-events: auto;
      appearance: none;
      border: 1px solid var(--ui2);
      background: rgba(255, 255, 255, 0.06);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      transition: background 0.1s;
    }
    button:hover { background: rgba(255, 255, 255, 0.12); }
    button:active { transform: translateY(1px); }
    .hint {
      font-size: 12px;
      opacity: 0.85;
      line-height: 1.35;
      max-width: 280px;
    }
    .pill {
      font-size: 12px;
      opacity: 0.92;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--ui2);
      background: rgba(255,255,255,0.06);
      white-space: nowrap;
      font-variant-numeric: tabular-nums;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="panel">
      <div class="row">
        <button id="toggle">Retract: OFF</button>
        <div class="pill" id="stats">Nodes: 0</div>
      </div>
    </div>

    <div class="panel hint">
      <strong>Controls:</strong><br/>
      • Tap to spawn Creep Node<br/>
      • Drag to Pan<br/>
      • Pinch / Wheel to Zoom<br/>
    </div>
  </div>

  <script>
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp  = (a, b, t) => a + (b - a) * t;

    function hexToRgb(hex) {
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return m ? { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16) } : { r:255,g:0,b:255 };
    }
    function mixRgb(a, b, t) {
      return { 
        r: Math.round(lerp(a.r,b.r,t)), 
        g: Math.round(lerp(a.g,b.g,t)), 
        b: Math.round(lerp(a.b,b.b,t)) 
      };
    }

    // ---- noise (Fixed TypeErrors) ----
    function hash2(ix, iy, seed) {
      // FIX: Explicitly convert Number coordinates to BigInt before mixing
      const X = BigInt(ix);
      const Y = BigInt(iy);
      
      // Constants must also be BigInts (n suffix)
      let h = X * 374761393n + Y * 668265263n + seed * 1442695040888963407n;
      
      let x = Number(h & 0xffffffffn) >>> 0;
      x ^= x >> 16; x = Math.imul(x, 2246822507);
      x ^= x >> 13; x = Math.imul(x, 3266489909);
      x ^= x >> 16;
      return (x >>> 0) / 4294967295;
    }
    
    function smoothstep(t) { return t * t * (3 - 2 * t); }
    
    function valueNoise2(x, y, seedBigInt) {
      const x0 = Math.floor(x), y0 = Math.floor(y);
      const x1 = x0 + 1, y1 = y0 + 1;
      
      const sx = smoothstep(x - x0);
      const sy = smoothstep(y - y0);
      
      const n00 = hash2(x0, y0, seedBigInt);
      const n10 = hash2(x1, y0, seedBigInt);
      const n01 = hash2(x0, y1, seedBigInt);
      const n11 = hash2(x1, y1, seedBigInt);
      
      const ix0 = lerp(n00, n10, sx);
      const ix1 = lerp(n01, n11, sx);
      
      return lerp(ix0, ix1, sy);
    }
    
    function fbm2(x, y, seedBigInt) {
      let v = 0, a = 0.55, f = 1.0;
      for (let i = 0; i < 4; i++) {
        v += a * valueNoise2(x * f, y * f, seedBigInt + BigInt(i * 1013));
        f *= 2.0;
        a *= 0.5;
      }
      return v;
    }

    // ---- map ----
    const TRI_SIZE = 26;
    const GRID_W   = 90;
    const GRID_H   = 90;

    const h = TRI_SIZE * Math.sqrt(3) * 0.5;
    const mapWidth  = GRID_W * TRI_SIZE;
    const mapHeight = GRID_H * (2 * h);

    const triangles = [];
    function addTri(a, b, c) {
      const cx = (a.x + b.x + c.x) / 3;
      const cy = (a.y + b.y + c.y) / 3;
      const path = new Path2D();
      path.moveTo(a.x, a.y);
      path.lineTo(b.x, b.y);
      path.lineTo(c.x, c.y);
      path.closePath();

      const minX = Math.min(a.x, b.x, c.x);
      const minY = Math.min(a.y, b.y, c.y);
      const maxX = Math.max(a.x, b.x, c.x);
      const maxY = Math.max(a.y, b.y, c.y);

      // creep property: 0 = sand, 1 = full creep
      triangles.push({ a,b,c,cx,cy,minX,minY,maxX,maxY,path, creep: 0 });
    }
    
    function buildTriMap() {
      triangles.length = 0;
      for (let y = 0; y < GRID_H; y++) {
        for (let x = 0; x < GRID_W; x++) {
          const ox = x * TRI_SIZE + ((y % 2) * (TRI_SIZE * 0.5));
          const oy = y * (2 * h);
          const p0 = { x: ox,                 y: oy };
          const p1 = { x: ox + TRI_SIZE,      y: oy };
          const p2 = { x: ox + TRI_SIZE*0.5,  y: oy + 2*h };
          const p3 = { x: ox - TRI_SIZE*0.5,  y: oy + 2*h };
          addTri(p0, p1, p2);
          addTri(p0, p2, p3);
        }
      }
    }

    // ---- creep logic ----
    const sources = [];
    let retractMode = false;

    function addSource(wx, wy) {
      const seed = BigInt((Math.random() * 1e9) | 0) + 1234567n;
      // Tendrils give the "star" shape initially
      const tendrilCount = 8 + ((Math.random() * 5) | 0);
      const tendrils = [];
      for (let i = 0; i < tendrilCount; i++) {
        tendrils.push({ 
          angle: Math.random() * Math.PI * 2, 
          strength: 0.5 + Math.random() * 0.5 
        });
      }
      
      sources.push({ 
        x: wx, 
        y: wy, 
        r: 0, 
        growSpeed: 100, 
        retractSpeed: 200, 
        maxR: 1200, 
        seed, 
        tendrils 
      });
    }

    function angularDelta(a, b) {
      let d = a - b;
      while (d > Math.PI) d -= Math.PI * 2;
      while (d < -Math.PI) d += Math.PI * 2;
      return d;
    }

    function tendrilMask(src, angle, dist) {
      // Organic widening: As creep grows (dist increases relative to max), 
      // the tendrils get wider (sigma increases)
      const baseSigma = 0.2; 
      // normalize distance for width calculation
      const nDist = clamp(dist / 600, 0, 1);
      const sigma = baseSigma + nDist * 0.8; 

      let best = 0;
      for (const t of src.tendrils) {
        const d = angularDelta(angle, t.angle);
        // Gaussian falloff based on angle
        const g = Math.exp(-(d * d) / (2 * sigma * sigma)) * t.strength;
        if (g > best) best = g;
      }

      // Add noise to the edge of the tendrils
      const n = fbm2(
        (Math.cos(angle) * 3.0 + src.x * 0.01) + dist * 0.005,
        (Math.sin(angle) * 3.0 + src.y * 0.01) + dist * 0.005,
        src.seed
      );

      return clamp((best * 1.2 + (n - 0.5) * 0.3), 0, 1);
    }

    function influenceAtTriangle(src, tri) {
      const dx = tri.cx - src.x;
      const dy = tri.cy - src.y;
      const dist = Math.hypot(dx, dy);
      if (dist > src.r) return 0;

      const angle = Math.atan2(dy, dx);
      
      // Hard edge at current radius
      const edge = clamp((src.r - dist) / 50, 0, 1);
      
      // Tendril shape
      const mask = tendrilMask(src, angle, dist);

      // Internal noise texture for patchiness
      const radialN = fbm2(tri.cx * 0.015, tri.cy * 0.015, src.seed + 777n);
      const radial = clamp(0.7 + (radialN - 0.5) * 0.4, 0, 1);

      return clamp(mask * edge * radial, 0, 1);
    }

    // ---- camera ----
    const cam = { x: mapWidth * 0.5, y: mapHeight * 0.5, scale: 1.0 };
    let DPR = 1;

    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha: false });

    function screenToWorld(sx, sy) {
      const rect = canvas.getBoundingClientRect();
      const x = (sx - rect.width  * 0.5) / cam.scale + cam.x;
      const y = (sy - rect.height * 0.5) / cam.scale + cam.y;
      return { x, y };
    }

    function clampCamera() {
      const rect = canvas.getBoundingClientRect();
      const halfW = rect.width  * 0.5 / cam.scale;
      const halfH = rect.height * 0.5 / cam.scale;
      const pad = 300;
      cam.x = clamp(cam.x, -pad + halfW, mapWidth + pad - halfW);
      cam.y = clamp(cam.y, -pad + halfH, mapHeight + pad - halfH);
      cam.scale = clamp(cam.scale, 0.25, 4.0);
    }

    const sand = hexToRgb(getComputedStyle(document.documentElement).getPropertyValue("--sand").trim());
    const sandDark = hexToRgb(getComputedStyle(document.documentElement).getPropertyValue("--sand-dark").trim());
    const purple = hexToRgb(getComputedStyle(document.documentElement).getPropertyValue("--purple").trim());

    function resize() {
      DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      const w = Math.floor(window.innerWidth * DPR);
      const h = Math.floor(window.innerHeight * DPR);
      canvas.width = w;
      canvas.height = h;
      canvas.style.width = window.innerWidth + "px";
      canvas.style.height = window.innerHeight + "px";
      clampCamera();
    }

    function setTransformCssToDevice(a, b, c, d, e, f) {
      ctx.setTransform(a * DPR, b * DPR, c * DPR, d * DPR, e * DPR, f * DPR);
    }

    function draw() {
      const rect = canvas.getBoundingClientRect();

      // Background
      setTransformCssToDevice(1,0,0,1,0,0);
      ctx.fillStyle = "#0f0f12";
      ctx.fillRect(0, 0, rect.width, rect.height);

      // World Transform
      const sx = cam.scale;
      const sy = cam.scale;
      const tx = rect.width * 0.5 - cam.x * cam.scale;
      const ty = rect.height * 0.5 - cam.y * cam.scale;
      setTransformCssToDevice(sx, 0, 0, sy, tx, ty);

      // View Culling
      const viewMin = screenToWorld(0, 0);
      const viewMax = screenToWorld(rect.width, rect.height);
      const minX = Math.min(viewMin.x, viewMax.x) - 100;
      const minY = Math.min(viewMin.y, viewMax.y) - 100;
      const maxX = Math.max(viewMin.x, viewMax.x) + 100;
      const maxY = Math.max(viewMin.y, viewMax.y) + 100;

      // Draw Triangles
      // Optimization: Calculate colors
      for (const tri of triangles) {
        if (tri.maxX < minX || tri.minX > maxX || tri.maxY < minY || tri.minY > maxY) continue;

        // Base ground noise
        const nv = fbm2(tri.cx * 0.02, tri.cy * 0.02, 999n);
        const sandT = clamp((nv - 0.35) * 1.25, 0, 1);
        const base = mixRgb(sand, sandDark, sandT);

        // Mix with Creep
        const t = smoothstep(tri.creep); // Smoothstep makes the edges cleaner
        const col = mixRgb(base, purple, t);

        ctx.fillStyle = `rgb(${col.r},${col.g},${col.b})`;
        ctx.fill(tri.path);
      }

      // Draw Grid Lines (Subtle)
      ctx.lineWidth = 1 / cam.scale;
      ctx.strokeStyle = "rgba(0,0,0,0.15)";
      for (const tri of triangles) {
        if (tri.maxX < minX || tri.minX > maxX || tri.maxY < minY || tri.minY > maxY) continue;
        ctx.stroke(tri.path);
      }

      // Draw Source Nodes
      for (const s of sources) {
        ctx.beginPath();
        ctx.arc(s.x, s.y, 8 / cam.scale, 0, Math.PI * 2);
        ctx.fillStyle = "#fff";
        ctx.fill();

        ctx.beginPath();
        ctx.arc(s.x, s.y, 10 / cam.scale, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(0,0,0,0.5)";
        ctx.lineWidth = 2 / cam.scale;
        ctx.stroke();
      }
    }

    // ---- Loop ----
    let last = performance.now();
    function step(now) {
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;

      // Update Creep Sources
      for (let i = sources.length - 1; i >= 0; i--) {
        const s = sources[i];
        if (!retractMode) {
          if(s.r < s.maxR) s.r += s.growSpeed * dt;
        } else {
          s.r -= s.retractSpeed * dt;
          if (s.r <= 1) sources.splice(i, 1);
        }
      }

      // Update Map State
      if (sources.length === 0) {
        // Quick clear if empty
        if(triangles[0].creep > 0) {
           for (const tri of triangles) tri.creep = 0;
        }
      } else {
        // Evaluate influence
        // To optimize: only check triangles somewhat near sources? 
        // For prototype, brute force with culling is okay for < 10k tris
        
        // We only update "active" creep roughly. 
        // For smooth animation we lerp the values.
        for (const tri of triangles) {
          let target = 0;
          
          // Optimization: Simple distance check before expensive influence calc
          let inRange = false;
          for (const s of sources) {
            if (Math.abs(s.x - tri.cx) < s.r && Math.abs(s.y - tri.cy) < s.r) {
              const inf = influenceAtTriangle(s, tri);
              if (inf > target) target = inf;
              if (target >= 1) break;
            }
          }
          
          // Animate the creep value towards target
          const rate = target > tri.creep ? 2.0 : 0.8; 
          tri.creep += (target - tri.creep) * rate * dt;
        }
      }

      draw();
      document.getElementById("stats").textContent = `Nodes: ${sources.length}`;
      requestAnimationFrame(step);
    }

    // ---- Input ----
    const pointers = new Map();
    let isDragging = false;
    let lastDragWorld = null;
    let tapCandidate = null;

    canvas.addEventListener("pointerdown", (e) => {
      canvas.setPointerCapture(e.pointerId);
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      tapCandidate = { id: e.pointerId, sx: e.clientX, sy: e.clientY, time: performance.now(), moved: false };

      if (pointers.size === 1) {
        isDragging = true;
        lastDragWorld = screenToWorld(e.clientX, e.clientY);
      }
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!pointers.has(e.pointerId)) return;
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (tapCandidate && tapCandidate.id === e.pointerId) {
        const dx = e.clientX - tapCandidate.sx;
        const dy = e.clientY - tapCandidate.sy;
        if (dx*dx + dy*dy > 100) tapCandidate.moved = true;
      }

      if (pointers.size === 1 && isDragging) {
        const w = screenToWorld(e.clientX, e.clientY);
        cam.x += (lastDragWorld.x - w.x);
        cam.y += (lastDragWorld.y - w.y);
        lastDragWorld = screenToWorld(e.clientX, e.clientY);
        clampCamera();
      }

      if (pointers.size === 2) {
        const pts = Array.from(pointers.values());
        const p0 = pts[0], p1 = pts[1];
        const mid = { x: (p0.x + p1.x) * 0.5, y: (p0.y + p1.y) * 0.5 };
        const d = Math.hypot(p1.x - p0.x, p1.y - p0.y);

        if (!canvas._pinch) {
          canvas._pinch = {
            startDist: d,
            startScale: cam.scale,
            startMid: mid,
            worldAtMid: screenToWorld(mid.x, mid.y)
          };
        } else {
          const pinch = canvas._pinch;
          if (pinch.startDist > 0) {
            const zoom = d / pinch.startDist;
            cam.scale = clamp(pinch.startScale * zoom, 0.25, 4.0);

            const nowWorldAtMid = screenToWorld(mid.x, mid.y);
            cam.x += (pinch.worldAtMid.x - nowWorldAtMid.x);
            cam.y += (pinch.worldAtMid.y - nowWorldAtMid.y);
            clampCamera();
          }
        }
      }
    });

    canvas.addEventListener("pointerup", (e) => {
      pointers.delete(e.pointerId);
      if (pointers.size < 2) canvas._pinch = null;
      if (pointers.size === 0) {
        isDragging = false;
        lastDragWorld = null;
      }

      if (tapCandidate && tapCandidate.id === e.pointerId) {
        const elapsed = performance.now() - tapCandidate.time;
        if (!tapCandidate.moved && elapsed < 400) {
          const w = screenToWorld(e.clientX, e.clientY);
          addSource(w.x, w.y);
        }
      }
      tapCandidate = null;
    });

    canvas.addEventListener("pointercancel", () => {
      pointers.clear();
      canvas._pinch = null;
      isDragging = false;
    });

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const before = screenToWorld(e.clientX, e.clientY);
      const zoom = Math.exp(-e.deltaY * 0.001);
      cam.scale = clamp(cam.scale * zoom, 0.25, 4.0);
      const after = screenToWorld(e.clientX, e.clientY);
      cam.x += (before.x - after.x);
      cam.y += (before.y - after.y);
      clampCamera();
    }, { passive: false });

    document.getElementById("toggle").addEventListener("click", () => {
      retractMode = !retractMode;
      document.getElementById("toggle").textContent = `Retract: ${retractMode ? "ON" : "OFF"}`;
    });

    // ---- init ----
    buildTriMap();
    cam.x = mapWidth * 0.5;
    cam.y = mapHeight * 0.5;
    cam.scale = 0.6; // Start zoomed out a bit

    window.addEventListener("resize", resize);
    resize();
    requestAnimationFrame(step);
  </script>
</body>
</html>
